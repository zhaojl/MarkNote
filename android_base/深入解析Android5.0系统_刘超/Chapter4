第四章 进程间通信 － Android 的 Binder



Binder 是 Android 特有的一种进程间通信(IPC)方式. Android Binder 的前身是 OpenBinder, 最早由 Dianne Hackborn 开发并用于 PalmOS 上,
后来 Dianne Hackborn 加入 google, 在 OpenBinder 的基础上开发了 Android Binder.


本章涉及的源码路径
/frameworks/native/libs/binder/Binder.cpp
/frameworks/native/libs/binder/BpBinder.cpp
/frameworks/native/libs/binder/IInterface.cpp
/frameworks/native/libs/binder/IServiceManager.cpp
/frameworks/native/libs/binder/IResultReceiver.cpp
/frameworks/native/libs/binder/IShellCallback.cpp
/frameworks/native/libs/binder/Parcel.cpp
/frameworks/native/libs/binder/include/binder/IBinder.h
/frameworks/native/libs/binder/include/binder/Binder.h
frameworks/native/libs/binder/include/binder/BinderService.h
/frameworks/native/libs/binder/include/binder/BpBinder.h
/frameworks/native/libs/binder/include/binder/IInterface.h
/frameworks/native/libs/binder/include/binder/Parcel.h
/frameworks/native/libs/binder/include/binder/Parcelable.h




4.1 Binder简介
    Binder 和传统的IPC机制相比, 融合了远程过程调用(RPC)的概念, 而且这种远程调用不是传统的面向过程的远程调用, 而是一种面向对象的远程调用.

    从 Unix 发展而来的 IPC 机制, 只能提供比较原始的进程间通信手段, 通信的双方必须处理线程同步,内存管理等复杂问题, 不但工作量大,而且很容易出错.
    除了 socket, 匿名管道(Pipe)以外, 传统的IPC, 如命名管道(FIFO), 信号量(Semaphore), 消息队列等已经从 Android中去掉了.
    和其他 IPC 相比较, Socket 是一种比较成熟的通信手段, 同步控制也很容易实现. Socket 用于网络通信非常合适, 但是用于进程间通信, 效率就不太高了.

    Android 在架构上一直希望模糊进程的概念, 取而代之以组件的概念. 应用不需要关心组件存放的位置,组件运行在哪个进程中,组件的生命周期等问题.
    随时随地, 只要拥有 Binder 对象, 就能使用组件的功能. Binder 就像一张网, 将整个系统的组件, 跨越进程和线程, 组织在了一起.

    Binder 很强大, 也很复杂.   但是无论调用 Binder 服务, 还是开发一个 Binder 服务都是一件很轻松的事情, 不需要考虑线程同步,内存分配等问题,
    和开发一个普通的类没有太大的区别, 所有这些麻烦问题都在 Binder 框架中解决了.

    正因为如此, Android 系统的服务都是利用 Binder 构建的. Android 系统中的服务有几十种之多, 这是任何一个其他嵌入式平台都不具备的.

    Binder 是整个系统运行的中枢, 因此, Android 在提高 Binder 的效率方面也是下足了功夫.

    Android 在进程间传递数据使用的是共享内存方式, 这样数据只需要复制一次就能从一个进程到达另一个进程. 而一般的IPC都需要两步, 从用户进程复制到内核, 再从内核复制到服务进程.

    在安全性方面 Android 也做了考虑, Binder 调用时会传递调用进程的 euid 到服务端, 因此, 服务端可以通过检查调用进程的权限来决定是否允许其使用所调用的服务.


4.1.1 Binder对象定义
    Binder 涉及的对象比较多, 很容易混淆, 为了行文方便, 这里对 Binder 对象做出了定义, 这些并非官方的定义, 只是本文使用的代称.

    (1) Binder 实体对象: Binder 实体对象就是 Binder 服务的提供者.
                        一个提供 Binder 服务的类必须继承 BBinder 类, 有时为了强调对象的类型, 也用 "BBinder 对象" 来代替 "Binder 实体对象".

    (2) Binder 引用对象: Binder 引用对象是 Binder 实体对象在客户进程的代表.
                        每个引用对象的类型都是 BpBinder 类, 同样可以用名称 "BpBinder 对象" 来代替 "Binder 引用对象".

    (3) Binder 代理对象: 代理对象也成为接口对象, 它主要是为客户端的上层应用提供接口服务, 从 IInterface 类派生.
                        它实现了 Binder 服务的函数接口, 当然只是一个转调的空壳.
                        通过代理对象, 应用能像使用本地对象一样使用远端的实体对象提供的服务.

    (4) IBinder 对象: BBinder 和 BpBinder 类都是从 IBinder 类中继承而来.
                     在很多场合, 不需要刻意的去区分实体对象和引用对象, 这时可以使用 "IBinder 对象" 来统一称呼它们.

    Binder 代理对象主要和应用程序打交道, 将 Binder 代理对象和引用对象分开的好处是代理对象可以有很多实例, 但是它们包含的是同一个引用对象, 这样方便了用户层的使用.

    下图简易表示了 Binder 对象之间的关系:
                客户进程                                 服务进程
            Binder接口对象----->
                                Binder 引用对象------->Binder实体对象
            Binder接口对象----->              |         |
                                             |         |
                                             (IBinder对象)
    应用完全可以抛开接口对象直接使用 Binder 的引用对象, 但是这样开发的程序兼容性不好.
    也正是在客户端将引用对象和代理对象分离, Android 才能用一套架构来同时为 java 和 native 层提供 Binder 服务.
    隔离后, Binder 底层不需要关心上层的实现细节, 只需要和 Binder 实体对象和引用对象交互.

    在 /frameworks/native/libs/binder/include/binder/IBinder.h 文件中有如下定义:
        namespace android {
            class BBinder;
            class BpBinder;
            class IInterface;
            class Parcel;
            class IResultReceiver;
            class IShellCallback;

            /**
             * Base class and low-level protocol for a remotable object.
             * You can derive from this class to create an object for which other processes can hold references to it.
             * Communication between processes (method calls, property get and set) is down through a low-level protocol implemented on top of the transact() API.
             */
            class IBinder : public virtual RefBase {


4.1.2 Binder的架构
    Binder 通信的参与者由四部分组成:
        (1) Binder 驱动        Binder 的核心, 实现各种 Binder 的底层操作.
        (2) ServiceManager    提供 Binder 的名称到引用对象的转换服务.
        (3) 服务端             Binder 服务的提供者
        (4) 客户端             Binder 服务的使用者

    这四部分的关系图如下所示:
                    服务端进程  客户端进程
                        |        |
        用户空间       Binder库(libbinder)     ServiceManager 守护进程
                                    Binder驱动(内核空间 )

    Binder 驱动位于 Binder 架构的核心, 通过文件系统的标准接口, 如 open(), ioctl(), mmap()等向用户层提供服务, 应用层和 Binder 驱动之间的数据交换是通过 ioctl() 接口完成的, read() 和 write() 两个常用的接口反而没有使用.
    Binder 的数据交换过程比较复杂, 而且涉及两个进程间的数据传输, 如果读写用两个不同的接口来分别实现, 会导致实现比现在更加复杂.
    使用 ioctl() 的好处是一次系统调用就能完成用户系统和驱动之间的双向数据交换, 不但简化了控制逻辑, 也提高了传输效率.
    Binder 驱动的主要功能是提供 Binder 通信的通道, 维护 Binder 对象的引用计数, 转换传输中的 Binder 实体对象和引用对象以及管理数据缓存区.

    ServiceManager 是一个守护进程, 它的作用是提供 Binder 服务的查询功能, 返回被查询服务的引用. 对于一个 Binder 服务, 通常会有一个唯一的字符串标识, 只要它向 ServiceManager 注册了这个标识, 应用就可以通过标识来获取服务的引用对象.
    ServiceManager 是一个单独的进程, 它是通过什么方式来给其他进程提供查询服务的呢? 实际上 ServiceManager 也是通过 Binder 框架来提供服务.

    作为一个Binder服务提供者, ServiceManager 也需要通过某种方式让使用者得到它的引用对象. Android 使用了一种很巧妙,也很简单的方法来解决这个问题.
    Binder 引用对象的核心数据是一个实体对象的引用号, 它是在驱动内部分配的一个值. Binder 框架硬性规定了 0 代表 ServiceManager.
    这样用户进程就可以使用参数"0" 直接构造出 ServiceManager 的引用对象, 然后开始使用 ServiceManager 的查询服务.

    既然驱动是 Binder 的核心, 为什么不直接把查找引用对象的功能放在驱动中完成呢? 还要在 ServiceManager 的进程中绕一圈.
    其实这个Android的安全管理有关系, Android 中并不允许任意的进程都能注册 Binder 服务, 虽然任意一个进程都能创建 Binder 服务, 但是只有root进程或system进程才可以才可以不受限制的向ServiceManager注册服务.
    ServiceManager 中有一张表, 里面规定了能够注册服务的进程的用户ID, 以及进程能够注册的服务名称, ServiceManager 通过这张表来控制普通进程的注册请求(Android 5.0 通过 SELinux 而不是查表的方式来检查权限),
    这也是 ServiceManager 存在的原因.

    Binder 服务可以分为两种: 实名服务和匿名服务. 它们从开发到使用没有任何区别, 唯一的区别是实名服务能够通过 ServiceManager 查询到.
    Android 中的实名 Binder 服务都是系统提供的如 ActivityManagerService, PowerManagerService, WindowManagerService等.
    普通应用开发的 Binder 服务, 只能是匿名服务.

    如果匿名服务不能通过 ServiceManager 查询到, 使用者通过什么方式才能得到它的引用对象呢? 答案还是通过 Binder.
    匿名服务经常使用的场景是服务端进程回调客户端进程的函数, 整个过程是:
    客户端和服务端通过 Binder 连接上之后, 客户端把本进程中创建的匿名服务的实体对象作为函数参数传递到服务端, 驱动会在中间把实体对象"转换"成引用对象, 这样服务进程就得到了客户进程创建的 Binder 服务的引用对象, 然后就能回调客户进程中 Binder 服务的函数了.

    在 java 层 Android 提供了通过组件 Service 的方式来包装和使用匿名服务. 下面详细介绍这种方式.

4.1.3 组件 Service 和 匿名 Binder 服务
    如果对 Android 的理解不够深入, 可能会将 Android 四大组件之一的 Service 和 Binder 服务混为一谈. 不过这两者的确关系紧密: 组件 Service 其实包含了 Binder 服务.

    这里为什么要强调它们的区别呢? 首先是为了澄清概念. 我们谈论组件 Service 时, 更多的是关心它的生命周期,启动和结束之类的问题, 而 Binder 服务和生命周期没有太大关系, 两者不能混为一谈.
    否则在开发带有组件 Service 的程序时, 可能会对里面的一些细节感到迷惑, 同时借这个问题可以更深入地讨论匿名 Binder 服务的使用.
    匿名服务因为没有 ServiceManager 类提供名称解析服务, 因此一般只能用于服务进程回调客户进程.
    但是 Android 还通过 Framework 提供了一种启动 java 匿名 Binder 服务的方法. 这种方法的过程如下:
    首先某个应用通过调用 bindService() 方法发出一个 Intent, Framework 根据 Intent 找到对应的组件 Service 并启动它, 包在组件 Service 中的Binder 服务也将同时创建出来.
    随后, Framework 会把服务的 IBinder 对象通过 ServiceConnection 的回调方法 onServiceConnected() 传回到应用, 这样应用就得到匿名 Binder 服务的引用对象, 也就能使用组件 Service 中的匿名 Binder 服务了.
    在这里 Android 的 Framework 用 Intent 代替了 Binder 服务的名称来查找对应的服务, 同时也承担了 ServiceManager 的工作, 解析 Intent 并传回服务的引用对象.

    Android 的 Framework 并没有使用新的技术来传递 Binder 对象, 因为 Framework 中担任这个角色的 ActivityManagerService 本身就是一个 Binder 服务, 最终还是通过 Binder 框架在服务端和客户端之间传递了 IBinder 对象.


4.1.4 Binder的层次
    从代码实现上划分, Binder 设计的类可以分成四个层次:
        Binder 驱动  <---->  IPCThreadState (libbinder)  <---->  Binder核心类 (libbinder)  <---->  服务类和接口类
        最上层是位于Framework中的各种 Binder 服务类和它们的接口类. 这一层的类非常多, 例如常见的 ActivityManagerService, PackageManagerService, WindowManagerService等, 它们为应用程序提供了各种各样的服务.
        第二层是 libbinder 中用于服务类和接口类开发的基础, 如 IBinder, BBinder, BpBinder等.
        第三层是和驱动交互的 IPCThreadState 和 ProcessState 类.
        最底层的是 Binder 驱动.

    这里刻意把中间的 libbinder 中的类划分成2个层次的原因是在这4层中, 第一层和第二层联系很紧密, 第二层中的各种 Binder 类用来支撑服务类和代理类的开发.
    但是第三层的 IPCThread 和第四层的驱动之间耦合的很厉害, 单独理解 IPCThread 或者是驱动都是一件很难的事, 必须把它们结合起来理解, 这一点正是 Binder 架构被人诟病的地方,
    驱动和应用层之间过于耦合, 违反了 Linux 驱动设计的原则, 因此, 主流的 Linux 并不愿意接纳 Binder.



4.2 如何使用Binder
    本节将介绍如何使用Binder, 包括两部分的内容: 一是如何使用已有的Binder服务, 而是如何开发Binder服务.

    就开发语言而言 Binder服务可以用 Java 实现, 也可以用 C++实现. 通常我们在 java 代码中调用 Java 语言实现的服务, 在C++代码中调用C++编写的服务, 但是从原理上讲,二者可以混合调用.

    应用可以在任意的进程和线程中使用 Binder 服务的功能, 不用担心同步,死锁等棘手的问题.


4.2.1 使用Binder服务
    C++层和Java层使用Binder 服务的方式基本一样, 包括函数的接口类型都相同, 这里介绍就不区分C++和Java了.

    使用Binder服务前要得到它的引用对象.
        private static final String CAMERA_SERVICE_BINDER_NAME = "media.camera";
        IBinder cameraServiceBinder = ServiceManager.getService(CAMERA_SERVICE_BINDER_NAME);
        if (cameraServiceBinder == null) {
            return;
        }
        ICameraService cameraService = ICameraService.Stub.asInterface(cameraServiceBinder);


4.2.2 Binder的混合调用

4.2.3 用 Java 开发 Binder 服务
    开发一个 Java 服务比C++服务简单的多.

        (1) 第一步, 选中 module app 中 main 目录, 依次点击 File -> New -> AIDL -> AIDL File, 然后输入 Interface Name 回车, 查看生成的 aidl 文件内容如下:
            package com.zhaojl;
            interface IExampleService {
                // 创建 aidl 文件时自带, Demonstrates some basic types that you can use as parameters and return values in AIDL.
                void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);
                // 自己添加的方法
                String get();
                void set(String value);
            }
            注:
                AIDL 是 Android Interface Description Language 的缩写, 它是 Android 提供的一种用来简化 Binder 编程的脚本语言.
                开发人员只需要在 AIDL 文件中定义出方法接口, AIDL 解释器能自动生成服务器和客户端需要的 Java 代码, 这也是 Java 服务比C++服务更容易开发的原因.

        (2) 第二步, 编写 Service 的代码:
            选中 module app 中 java 目录下的 package, 依次点击 File -> New -> Service -> Service, 然后输入 ExampleService 回车, 查看Service 代码:
            public class ExampleService extends Service {

                String name = "ABC";

                private final IExampleService.Stub mInstance = new IExampleService.Stub() {
                    @Override
                    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {
                    }

                    @Override
                    public String get() throws RemoteException {
                        return name;
                    }

                    @Override
                    public void set(String value) throws RemoteException {
                        name = value;
                    }
                };

                public ExampleService() {
                }

                @Override
                public IBinder onBind(Intent intent) {
                    return mInstance;
                }
            }
            注:
                ExampleService 需要从 Service 类继承, 而且必须重载底层的 onBind() 方法, 并在其中返回 Binder 服务的实体对象 mInstance.
                IExampleService.Stub 类是真正的 Binder 服务类, 它是通过前面的AIDL文件自动生成的, 因此, 这里还需要继承 IExampleService.Stub 并重载它的方法 get() 和 set(), 并实现它们的功能.

        (3) 第三步, 在 AndroidManifest.xml 中加入服务的声明:
            <service android:name=".ExampleService">
                <intent-filter>
                    <action android:name="com.android.IExampleService" />
                </intent-filter>
            </service>
            注:
                这里加入声明的作用是为了让 Framework 能通过 Intent 来找到 Service.
                在 Java 层开发 Binder 服务并不一定要使用组件 Service, 我们也可以开发一个单纯的 Java Binder 服务, 但是, 在应用中写出来的 Binder 服务无法被外界使用, 还需要通过某种途径把它的引用对象传递到使用者手中, 因此这里给出了一个使用组件 Service 的例子.


4.2.4 用C++ 开发Binder服务
    用 C++ 来实现 Binder 服务比较麻烦的原因是没有AIDL的辅助, 必须手工来写中间层代码, 但是, 这样反而有利于我们了解 Binder 的框架.
    下面我们把前面这个简单的服务用C++再写一遍.
    模板类 BnInterface 和 BpInterface 在 /frameworks/native/libs/binder/include/binder/IInterface.h 文件中的定义代码如下:
        namespace android {

            class IInterface : public virtual RefBase {             //定义 IInterface 接口
                public:
                    IInterface();
                    static sp<IBinder>  asBinder(const IInterface*);
                    static sp<IBinder>  asBinder(const sp<IInterface>&);

                protected:
                    virtual                     ~IInterface();
                    virtual IBinder*            onAsBinder() = 0;
            };

            template<typename INTERFACE>
            class BnInterface : public INTERFACE, public BBinder {  //定义 BnInterface
                public:
                    virtual sp<IInterface>      queryLocalInterface(const String16& _descriptor);   //后面会详细介绍
                    virtual const String16&     getInterfaceDescriptor() const;

                protected:
                    virtual IBinder*            onAsBinder();
            };

            template<typename INTERFACE>
            class BpInterface : public INTERFACE, public BpRefBase { //定义 BpInterface
                public:
                    explicit                    BpInterface(const sp<IBinder>& remote);

                protected:
                    virtual IBinder*            onAsBinder();
            };

    transaction_flags 在 /bionic/libc/kernel/uapi/linux/android/binder.h 文件中的定义代码如下:
    enum transaction_flags {
        TF_ONE_WAY = 0x01,      // 如果客户端调用 Binder 服务时不打算等待对方运行结束就继续运行, 可以使用 TF_ONE_WAY 作为 transcat() 函数的第四个参数, 表明使用异步的方式调用 Binder 服务, 这种方式意味着无法得到返回值
        TF_ROOT_OBJECT = 0x04,
        TF_STATUS_CODE = 0x08,
        TF_ACCEPT_FDS = 0x10,
    };


4.3 Binder应用层的核心类
    Android 在 Nougat 7.0 中引入 Android.bp 及其相关工具链, 引入 Android.bp 的目的是用来替换Android.mk的配置文件(它使用 Blueprint 框架来解析，最终转换成 Ninja 文件, 更多信息自行百度).

    libbinder 库中的IInterface, BpInterface, BnInterface, BBinder, BpBinder 和 IBinder 共同构成了 Binder 应用层的核心类.
    libbinder 库的编译配置文在 /frameworks/native/libs/binder/Android.bp 中的定义如下:
        cc_library {
            name: "libbinder",

            // for vndbinder
            vendor_available: true,
            vndk: {
                enabled: true,
            },

            srcs: [
                "ActivityManager.cpp",
                "AppOpsManager.cpp",
                "Binder.cpp",
                "BpBinder.cpp",
                "BufferedTextOutput.cpp",
                "Debug.cpp",
                "IActivityManager.cpp",
                "IAppOpsCallback.cpp",
                "IAppOpsService.cpp",
                "IBatteryStats.cpp",
                "IInterface.cpp",
                "IMediaResourceMonitor.cpp",
                "IMemory.cpp",
                "IPCThreadState.cpp",
                "IPermissionController.cpp",
                "IProcessInfoService.cpp",
                "IResultReceiver.cpp",
                "IServiceManager.cpp",
                "IShellCallback.cpp",
                "IUidObserver.cpp",
                "MemoryBase.cpp",
                "MemoryDealer.cpp",
                "MemoryHeapBase.cpp",
                "Parcel.cpp",
                "PermissionCache.cpp",
                "PermissionController.cpp",
                "PersistableBundle.cpp",
                "ProcessInfoService.cpp",
                "ProcessState.cpp",
                "Static.cpp",
                "Status.cpp",
                "TextOutput.cpp",
                "IpPrefix.cpp",
                "Value.cpp",
                ":libbinder_aidl",
            ],
            ......
        }
        // AIDL interface between libbinder and framework.jar
        filegroup {
            name: "libbinder_aidl",
            srcs: [
                "aidl/android/content/pm/IPackageManagerNative.aidl",
            ],
        }

4.3.1 IInterface中的两个宏
    IInterface 中的两个宏在 /frameworks/native/libs/binder/include/binder/IInterface.h 文件中定义如下:
        // 宏 DECLARE_META_INTERFACE 的定义如下
            #define DECLARE_META_INTERFACE(INTERFACE)
            static const ::android::String16 descriptor;                        
            static ::android::sp<I##INTERFACE> asInterface(const ::android::sp<::android::IBinder>& obj);
            virtual const ::android::String16& getInterfaceDescriptor() const;  
            I##INTERFACE();                                                     
            virtual ~I##INTERFACE();                                            

        // 宏 IMPLEMENT_META_INTERFACE 的定义如下
            #define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)
            const ::android::String16 I##INTERFACE::descriptor(NAME);           
            const ::android::String16& I##INTERFACE::getInterfaceDescriptor() const {
                return I##INTERFACE::descriptor;                                
            }                                                                   
            ::android::sp<I##INTERFACE> I##INTERFACE::asInterface(const ::android::sp<::android::IBinder>& obj) {
                ::android::sp<I##INTERFACE> intr;                               
                if (obj != NULL) {                                              
                    intr = static_cast<I##INTERFACE*>(obj->queryLocalInterface(I##INTERFACE::descriptor).get());
                    if (intr == NULL) {                                         
                        intr = new Bp##INTERFACE(obj);                          
                    }                                                           
                }                                                               
                return intr;                                                    
            }                                                                   
            I##INTERFACE::I##INTERFACE() { }                                    
            I##INTERFACE::~I##INTERFACE() { }                                   

        // 宏 CHECK_INTERFACE 的定义如下
        #define CHECK_INTERFACE(interface, data, reply)                         
            if (!(data).checkInterface(this)) { return PERMISSION_DENIED; }     
    注:
        (1)使用宏 DECLARE_META_INTERFACE 将加入一些成员变量和方法到我们定义的类中, 对于前面的例子, 相当于添加了下面的代码:
            static const ::android::String16 descriptor;
            static ::android::sp<IExampleService> asInterface(const ::android::sp<::android::IBinder>& obj);
            virtual const ::android::String16& getInterfaceDescriptor() const;
            IExampleService();
            virtual ~IExampleService();
        注意:
            这里添加了 静态成员变量 descriptor, 静态函数 asInterface(), 以及类的构造函数和析构函数.
            可能因为这些变量和函数是每个 Binder 服务的实现中都需要提供的, 为了方便开发, Android 把它们定义成了宏.
            开发服务时直接在类定义里使用这个宏, 方便也不容易出错.

        (2) 宏 IMPLEMENT_META_INTERFACE 是这些函数的实现, 这个宏定义比较长, 看上去有些乱, 下面看前面的例子中使用宏"展开"之后的代码:
                const ::android::String16 IExampleService::descriptor("ExampleService");
                const ::android::String16&  IExampleService::getInterfaceDescriptor() const {
                    return IExampleService::descriptor;
                }
                ::android::sp<IExampleService> IExampleService::asInterface(const ::android::sp<::android::IBinder>& obj) {
                    ::android::sp<IExampleService> intr;
                    if (obj != NULL) {
                        intr = static_cast<IExampleService*>(obj->queryLocalInterface(IExampleService::descriptor).get());
                        if (intr == NULL) {
                            intr = new BpExampleService(obj);
                        }
                    }
                    return intr;
                }
                IExampleService::IExampleService() { }
                IExampleService::~IExampleService() { }
         注意:
            变量 descriptor 是一个字符串, 描述了 Binder 服务, 在检查从客户端传递的参数是否合法时需要用到它.
            函数 asInterface() 主要作用是把 Binder 的引用对象转换成代理对象, 例如本例中的 IExampleService.
            asInterface() 函数很关键, 后面会深入介绍.



4.3.2 Binder核心类的关系

    libbinder 中类的继承关系图, 图4.6.
                    继承                                       BpRefBase
        IBinder    -------> BpBinder    继承                     |
                            BBinder  --------->  BnInterface   BpInterface
                                                        |实现    |实现
                                                        |        |
                                                        IInterface

    实际使用中这些类会分别用户客户端和服务端, 如果将一幅图折成两幅图, 看上去就会简单很多, 而且呈现的是一种完全对称的关系, 图4.7:
                              客户端                  服务端

                             IBinder                IBinder
                                |继承 IBinder          |继承 IBinder
                             BpBinder               BBinder
                                |聚合 BpBinder         |继承 BBinder
        IInterface<>接口 --> BpInterface            BnInterface <------- 接口IInterface<>
                        实现     |                                实现
                                |继承 BpRefBase
                             BpRefBase

    在 IBinder 类里有两个接口 localBinder() 和 remoteBinder(), 它们在 /frameworks/native/libs/binder/Binder.cpp 文件中的定义如下:
        BBinder* IBinder::localBinder() {
            return NULL;
        }
        BpBinder* IBinder::remoteBinder() {
            return NULL;
        }
        status_t BBinder::transact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
            data.setDataPosition(0);

            status_t err = NO_ERROR;
            switch (code) {
                case PING_TRANSACTION:
                    reply->writeInt32(pingBinder());
                    break;
                default:
                    err = onTransact(code, data, reply, flags);
                    break;
            }

            if (reply != NULL) {
                reply->setDataPosition(0);
            }

            return err;
        }
        status_t BBinder::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t /*flags*/){
             switch (code) {
                 case INTERFACE_TRANSACTION:
                     reply->writeString16(getInterfaceDescriptor());
                     return NO_ERROR;

                 case DUMP_TRANSACTION: {
                     int fd = data.readFileDescriptor();
                     int argc = data.readInt32();
                     Vector<String16> args;
                     for (int i = 0; i < argc && data.dataAvail() > 0; i++) {
                        args.add(data.readString16());
                     }
                     return dump(fd, args);
                 }

                 case SHELL_COMMAND_TRANSACTION: {
                     int in = data.readFileDescriptor();
                     int out = data.readFileDescriptor();
                     int err = data.readFileDescriptor();
                     int argc = data.readInt32();
                     Vector<String16> args;
                     for (int i = 0; i < argc && data.dataAvail() > 0; i++) {
                        args.add(data.readString16());
                     }
                     sp<IShellCallback> shellCallback = IShellCallback::asInterface(data.readStrongBinder());
                     sp<IResultReceiver> resultReceiver = IResultReceiver::asInterface(data.readStrongBinder());

                     // XXX can't add virtuals until binaries are updated.
                     //return shellCommand(in, out, err, args, resultReceiver);
                     (void)in;
                     (void)out;
                     (void)err;

                     if (resultReceiver != NULL) {
                         resultReceiver->send(INVALID_OPERATION);
                     }

                     return NO_ERROR;
                 }

                 case SYSPROPS_TRANSACTION: {
                     report_sysprop_change();
                     return NO_ERROR;
                 }

                 default:
                     return UNKNOWN_TRANSACTION;
             }
         }
    那么这两个函数 localBinder() 和 remoteBinder() 到底有什么实际用途?

    在编写代码时有时不是那么容易区分目前是运行在客户端进程还是运行在服务端进程.

    如果想确定一个 IBinder 对象到底是 BpBinder 还是 BBinder 对象时, 通过这两个函数的返回值就能判断出, 为什么请看书109页.


4.3.3 函数 asInterface 的奥秘
    asInterface() 函数是把 Binder 引用对象转换成代理对象的关键, asInterface() 的函数代码如下:
        ::android::sp<IExampleService> IExampleService::asInterface(const ::android::sp<::android::IBinder>& obj) {
            ::android::sp<IExampleService> intr;
            if (obj != NULL) {
                intr = static_cast<IExampleService*>(obj->queryLocalInterface(IExampleService::descriptor).get());
                if (intr == NULL) {
                    intr = new BpExampleService(obj);
                }
            }
            return intr;
        }
    注:
        asInterface() 函数的参数 obj 的类型是 IBinder, 实际调用时它既可能是 BpBinder 对象, 也可能是 BBinder 对象.

        如果传入的 obj 是一个 BpBinder 对象, 在 BpBinder/BpInterface 类中没有重载 queryLocalInterface() 函数, 因此 queryLocalInterface(IExampleService::descriptor).get() 调用将返回NULL,
        intr 的值是NULL, 这样接下来就会执行 intr = new BpExampleService(obj), 因此如果转换的是 BpBinder/BpInterface对象, 实际结果就是以 IBinder 对象为参数新创建一个代理对象.

        如果 obj 是一个实体对象 BBinder, 在这种情形下, 因为继承关系, BBinder 同时也会是一个 BnInterface 对象, 在 BnInterface 类中重载了 queryLocalInterface() 函数, 代码如下:
            template<typename INTERFACE>
            inline sp<IInterface> BnInterface<INTERFACE>::queryLocalInterface(const String16& _descriptor) {
                if (_descriptor == INTERFACE::descriptor) return this;  //
                return NULL;
            }
        如果参数传递的描述字符串和类的描述字符串相同, 函数将返回 this 指针, 这里的 this 就是 obj.
        因此调用 queryLocalInterface() 的结果是返回参数 obj 本身, 这样调用 asInterface() 函数的结果就是返回 obj 本身.

    asInterface() 函数的作用总结如下:
        (1)在客户进程中调用 asInterface(), 会新创建一个 Binder 代理对象, 代理对象中包含了引用对象.
        (2)在服务进程中调用 asInterface(), 直接返回参数的指针. 因为在服务进程中可以直接调用服务类, 无须再创建代理对象了.


4.3.4 Binder的“死亡通知”
    作为 Binder 服务的提供者, Binder 实体对象也会死亡, 可能是正常退出, 也可能是意外崩溃, 一旦实体对象死亡, 引用对象需要有机制来得到通知.

    1. 接收 Binder 的死亡通知

        IBinder 中提供了一个接口 linkToDeath(), 原型如下:
            virtual status_t linkToDeath(const sp<DeathRecipient>& recipient, void* cookie = NULL, uint32_t flags = 0) = 0;
        注:
            参数 DeathRecipient 是接收通知的对象, 需要自己定义. 例如,可以定义一个如下的类:
            class DeathRecipient : public virtual RefBase {
            public:
                virtual void binderDied(const wp<IBinder>& who) = 0;
            };
            当 Binder 服务死亡时, binderDied() 会被回调. 因此, 可以在这个函数中处理binder服务死亡后的事宜, 如释放资源, 清除指针或者重启 Binder 服务.


        linkToDeath() 函数会调用 IPCThreadState 的函数 requestDeathNotification() 来告诉驱动需要接收某个 Binder 服务死亡的通知消息, 函数代码如下:
            status_t BpBinder::linkToDeath(const sp<DeathRecipient>& recipient, void* cookie, uint32_t flags) {
                Obituary ob;
                ob.recipient = recipient;
                ob.cookie = cookie;
                ob.flags = flags;

                LOG_ALWAYS_FATAL_IF(recipient == NULL, "linkToDeath(): recipient must be non-NULL");

                {
                    AutoMutex _l(mLock);
                    if (!mObitsSent) {
                        if (!mObituaries) {
                            mObituaries = new Vector<Obituary>;
                            if (!mObituaries) {
                                return NO_MEMORY;
                            }
                            getWeakRefs()->incWeak(this);
                            IPCThreadState* self = IPCThreadState::self();  //调用 IPCThreadState
                            self->requestDeathNotification(mHandle, this);
                            self->flushCommands();
                        }
                        ssize_t res = mObituaries->add(ob);
                        return res >= (ssize_t)NO_ERROR ? (status_t)NO_ERROR : res;
                    }
                }
                return DEAD_OBJECT;
            }

    2. 投递死亡通知
        一旦驱动检测到某个 Binder 服务已经死亡, 会根据设置向应用层发送消息, IPCThreadState 中检测到死亡消息后, 利用保存在消息中的 BpBinder 指针, 调用其 sendObituary() 函数, 代码如下:
            status_t IPCThreadState::executeCommand(int32_t cmd) {
                BBinder* obj;
                RefBase::weakref_type* refs;
                status_t result = NO_ERROR;

                switch ((uint32_t)cmd) {
                    case BR_DEAD_BINDER: {
                            BpBinder *proxy = (BpBinder*)mIn.readPointer();
                            proxy->sendObituary();                  // 调用 sendObituary()
                            mOut.writeInt32(BC_DEAD_BINDER_DONE);
                            mOut.writePointer((uintptr_t)proxy);
                        } break;
                }

            void BpBinder::sendObituary() {
                mAlive = 0;
                if (mObitsSent) return;

                mLock.lock();
                Vector<Obituary>* obits = mObituaries;
                if(obits != NULL) {
                    IPCThreadState* self = IPCThreadState::self();
                    self->clearDeathNotification(mHandle, this);
                    self->flushCommands();
                    mObituaries = NULL;
                }
                mObitsSent = 1;
                mLock.unlock();
                if (obits != NULL) {
                    const size_t N = obits->size();
                    for (size_t i=0; i<N; i++) {
                        reportOneDeath(obits->itemAt(i));           // 调用 reportOneDeath()
                    }
                    delete obits;
                }
            }

            void BpBinder::reportOneDeath(const Obituary& obit) {
                sp<DeathRecipient> recipient = obit.recipient.promote();    //把弱引用转换成强引用, 再调用它的 binderDied() 方法
                if (recipient == NULL) return;
                recipient->binderDied(this);                        // 回调 DeathRecipient 对象的 binderDied() 方法
            }


4.3.5 Java层的Binder类

    Android 在 Java 层提供的 Binder 类, 下面看 Java Binder 类关系图.
                       Java 层的类          与之对应的 C++ 层的类
        IBinder ----> BinderProxy    --->  BpBinder
                      Binder         --->  JavaBBinderHolder (/frameworks/base/core/jni/android_util_Binder.cpp)
                                                |
                                            JavaBBinder
                                                |
                                              BBinder

    Java 层的 Binder 有自己的框架, 当然最后调用了 native 层的 BpBinder 和 BBinder 类, Java 层的 Binder 框架和 C++ 层的原理是一样的, 而且实现是通过 AIDL 来完成的.
    因此, 只要弄清 Java 框架中的这些类是通过什么方式和 C++ 中的 BpBinder 类 和 BBinder 类关联起来的就可以了.
    Java 层的 Binder 类也分为服务端和客户端两类, 我们先分析服务端使用的 Java 类.

    1. Java 层的 Binder 服务类
        开发一个 Java 服务, 必须继承 android.os.Binder 类, android.os.Binder 类的地位和 C++ 中的 BBinder 类相当.

        下面看看 Binder 类中最重要的成员定义代码如下:
            public class Binder implements IBinder {
                ......
                private final long mObject; // mObject 中存放的是 native 层关联对象的指针, Raw native pointer to JavaBBinderHolder object. Owned by this Java object. Not null.
                private IInterface mOwner;  // mOwner 存放的是 Binder 继承类的引用, 实际上就是 Java Binder 对象本身.
                private String mDescriptor; // mDescriptor 存放的是类的描述字符串
                ......
            }

        下面看看 android.os.Binder 类的构造函数如下:
            public Binder() {

                mObject = getNativeBBinderHolder(); // 给 mObject 赋值
                NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mObject);

                if (FIND_POTENTIAL_LEAKS) {
                    final Class<? extends Binder> klass = getClass();
                    if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) && (klass.getModifiers() & Modifier.STATIC) == 0) {
                        Log.w(TAG, "The following Binder class should be static or leaks might occur: " + klass.getCanonicalName());
                    }
                }
            }

        接下来调用到 native 层的 android_os_Binder_getNativeBBinderHolder() 函数在 /frameworks/base/core/jni/android_util_Binder.cpp 文件中的代码如下:
            static jlong android_os_Binder_getNativeBBinderHolder(JNIEnv* env, jobject clazz) {
                JavaBBinderHolder* jbh = new JavaBBinderHolder();
                return (jlong) jbh;
            }

        注:
            从android.os.Binder 类的构造函数代码可以看到, 它调用 getNativeBBinderHolder() 创建 JavaBBinderHolder 类的对象,
            并把指针保存在Java层 Binder类的mObject变量中.
            因此, JavaBBinderHolder 类是 Java层的Binder类和底层打交道的关键.

        下面看看 JavaBBinderHolder 类的定义:
            class JavaBBinderHolder {
            public:
                sp<JavaBBinder> get(JNIEnv* env, jobject obj) {
                    AutoMutex _l(mLock);
                    sp<JavaBBinder> b = mBinder.promote();
                    if (b == NULL) {
                        b = new JavaBBinder(env, obj);      // 创建 obj 的弱引用对象
                        mBinder = b;
                    }
                    return b;
                }
                sp<JavaBBinder> getExisting() {
                    AutoMutex _l(mLock);
                    return mBinder.promote();
                }

            private:
                Mutex           mLock;
                wp<JavaBBinder> mBinder;
            };

        JavaBBinder 类是从 BBinder类派生的, 它的主要数据成员如下:
            class JavaBBinder : public BBinder {
            private:
                 JavaVM* const   mVM;
                 jobject const   mObject; // GlobalRef to Java Binder
             };
        注:
            在这段代码中 mVM 保存的是 Java 虚拟机的指针, mObject 保存的是 android.os.Binder 在 native 层的 JNI 对象, 它是在调用 JavaBBinderHolder 的 get() 函数时传递进来的参数.
            因此 native 层的 BBinder 对象和 Java 层的 Binder 对象就相互关联起来了, 从驱动传递上来的 Binder 调用也就有通道到达 Java 层了.

        JavaBBinder 重载了 onTransact() 方法, 它会调用 Java 层 Binder 类的 execTransact() 方法, 具体请看下面代码:
            virtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0) {
                JNIEnv* env = javavm_to_jnienv(mVM);
                IPCThreadState* thread_state = IPCThreadState::self();
                const int32_t strict_policy_before = thread_state->getStrictModePolicy();
                ......
                jboolean res = env->CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast<jlong>(&data), reinterpret_cast<jlong>(reply), flags);
                ......
                return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;
            }

            static struct bindernative_offsets_t {
                jclass mClass;  // Class state.
                jmethodID mExecTransact;
                jfieldID mObject;   // Object state.

            } gBinderOffsets;

            static int int_register_android_os_Binder(JNIEnv* env) {
                jclass clazz = FindClassOrDie(env, kBinderPathName);
                gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz);
                gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, "execTransact", "(IJJI)Z");
                gBinderOffsets.mObject = GetFieldIDOrDie(env, clazz, "mObject", "J");

                return RegisterMethodsOrDie(env, kBinderPathName, gBinderMethods, NELEM(gBinderMethods));
            }
    对于服务端而言, 最重要就是了解 IPCThreadState 如何通过 BBinder 调用到 Java 层, 明白了这一点, 其余的就不用多分析了.

    下面看看客户端是如何把数据从 Java 层传递到驱动层的.

    2. Java 层的 Binder 引用类
        应用在 Java 层调用 Binder 同样也是通过 Binder 的代理对象来完成的,  和 C++ 中一样, 代理对象的生成也是通过接口类中的 asInterface()方法来完成的.

        Java 中的接口类一般都是 AIDL 自动生成的, 接着看上文中的实例 IExampleService.aidl 生成的 IExampleService.java 类中的代码:
            代码路径: app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/zhaojl/IExampleService.java
            public static com.zhaojl.IExampleService asInterface(android.os.IBinder obj) {
                if ((obj==null)) {
                    return null;
                }
                android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
                if (((iin!=null)&&(iin instanceof com.zhaojl.IExampleService))) {
                    return ((com.zhaojl.IExampleService)iin);
                }
                return new com.zhaojl.IExampleService.Stub.Proxy(obj);
            }

        下面看 ServiceManagerNative 的 getService()是如何得到这个 IBinder 对象的, 代码路径/frameworks/base/core/java/android/os/ServiceManagerNative.java
            public IBinder getService(String name) throws RemoteException {
                Parcel data = Parcel.obtain();
                Parcel reply = Parcel.obtain();
                data.writeInterfaceToken(IServiceManager.descriptor);
                data.writeString(name);
                mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);
                IBinder binder = reply.readStrongBinder();
                reply.recycle();
                data.recycle();
                return binder;
            }

        下面看 readStrongBinder() 函数实现, 代码路径/frameworks/base/core/jni/android_os_Parcel.cpp
            static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) {
                Parcel* parcel = reinterpret_cast<Parcel*>(nativePtr);
                if (parcel != NULL) {
                    return javaObjectForIBinder(env, parcel->readStrongBinder());
                }
                return NULL;
            }
        执行 parcel->readStrongBinder() 将会返回一个C++层的IBinder对象, 它实际上是一个 BpBinder 对象. 至于这个 BpBinder 对象是如何创建出来的, 下节将会详细介绍.
        javaObjectForIBinder() 函数中则会创建一个 Java 层的 BinderProxy 对象. BinderProxy类是从Binder 类派生的, 他就是我们要找的 Java 层中和C++层的 BpBinder 对应的引用类.
        只不过它的对象是在 native 层中创建的, 不是在Java代码中:
        下面看 javaObjectForIBinder() 函数代码如下, 代码路径/frameworks/base/core/jni/android_util_Binder.cpp
            jobject javaObjectForIBinder(JNIEnv* env, const sp<IBinder>& val) {
                ......
                BinderProxyNativeData* nativeData = gNativeDataCache;
                if (nativeData == nullptr) {
                    nativeData = new BinderProxyNativeData();
                }
                jobject object = env->CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());
                ......
                BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);
                if (actualNativeData == nativeData) {
                    // New BinderProxy; we still have exclusive access.
                    nativeData->mOrgue = new DeathRecipientList;
                    nativeData->mObject = val;
                    gNativeDataCache = nullptr;
                    ++gNumProxies;
                    if (gNumProxies >= gProxiesWarned + PROXY_WARN_INTERVAL) {
                        gProxiesWarned = gNumProxies;
                    }
                } else {
                    gNativeDataCache = nativeData;
                }
                return object;
            }



        gBinderProxyOffsets.mGetInstance 是 android.os.BinderProxy 类 getInstance()方法的 JNI 变量, 在 JNI 库装载时初始化, 请看如下代码:
            static struct binderproxy_offsets_t {
                jclass mClass;
                jmethodID mGetInstance;
                jmethodID mSendDeathNotice;
                jmethodID mDumpProxyDebugInfo;
                jfieldID mNativeData;  // Field holds native pointer to BinderProxyNativeData.
            } gBinderProxyOffsets;

            static int int_register_android_os_BinderProxy(JNIEnv* env) {
                jclass clazz = FindClassOrDie(env, "java/lang/Error");
                gErrorOffsets.mClass = MakeGlobalRefOrDie(env, clazz);

                clazz = FindClassOrDie(env, kBinderProxyPathName);
                gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz);
                gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, "getInstance", "(JJ)Landroid/os/BinderProxy;");
                gBinderProxyOffsets.mSendDeathNotice = GetStaticMethodIDOrDie(env, clazz, "sendDeathNotice", "(Landroid/os/IBinder$DeathRecipient;)V");
                gBinderProxyOffsets.mDumpProxyDebugInfo = GetStaticMethodIDOrDie(env, clazz, "dumpProxyDebugInfo", "()V");
                gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, "mNativeData", "J");

                clazz = FindClassOrDie(env, "java/lang/Class");
                gClassOffsets.mGetName = GetMethodIDOrDie(env, clazz, "getName", "()Ljava/lang/String;");

                return RegisterMethodsOrDie(env, kBinderProxyPathName, gBinderProxyMethods, NELEM(gBinderProxyMethods));
            }

        从 Java 层调用 Binder 服务使用的通道是 BinderProxy 类的 transact()方法, 这个本地方法在 C++ 中对应的实现如下, 代码路径/frameworks/base/core/jni/android_util_Binder.cpp:
            static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) {
                Parcel* data = parcelForJavaObject(env, dataObj);
                Parcel* reply = parcelForJavaObject(env, replyObj);
                IBinder* target = getBPNativeData(env, obj)->mObject.get();

                // Transact from Java code to target
                status_t err = target->transact(code, *data, reply, flags);

                if (err == NO_ERROR) {
                    return JNI_TRUE;
                } else if (err == UNKNOWN_TRANSACTION) {
                    return JNI_FALSE;
                }

                signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data->dataSize());
                return JNI_FALSE;
            }
            struct BinderProxyNativeData {
                sp<IBinder> mObject;
                sp<DeathRecipientList> mOrgue;  // Death recipients for mObject.
            };
            BinderProxyNativeData* getBPNativeData(JNIEnv* env, jobject obj) {
                return (BinderProxyNativeData *) env->GetLongField(obj, gBinderProxyOffsets.mNativeData);
            }
        这样我们就彻底了解了 Binder 从 Java 层到达驱动的路径.




4.4 Binder的实现原理

4.4.1 Binder 的线程模型
    1. Binder 的线程池
        onZygoteInit() 函数在 /frameworks/base/cmds/app_process/app_main.cpp 文件中的代码如下:
            virtual void onZygoteInit() {
                sp<ProcessState> proc = ProcessState::self();
                proc->startThreadPool();
            }

        ProcessState 类的 self()函数, 构造函数, 以及 startThreadPool()函数在 /frameworks/native/libs/binder/ProcessState.cpp 文件中的代码如下:
            sp<ProcessState> ProcessState::self() {
                Mutex::Autolock _l(gProcessMutex);
                if (gProcess != NULL) {
                    return gProcess;
                }
                gProcess = new ProcessState("/dev/binder");     // binder 设备 "/dev/binder"
                return gProcess;
            }

            #define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)
            #define DEFAULT_MAX_BINDER_THREADS 15
            ProcessState::ProcessState(const char *driver)
                : mDriverName(String8(driver))
                , mDriverFD(open_driver(driver))    //调用 open_driver()函数打开 Binder 设备
                , mVMStart(MAP_FAILED)
                , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)
                , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)
                , mExecutingThreadsCount(0)
                , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)
                , mStarvationStartTimeMs(0)
                , mManagesContexts(false)
                , mBinderContextCheckFunc(NULL)
                , mBinderContextUserData(NULL)
                , mThreadPoolStarted(false)
                , mThreadPoolSeq(1)
            {
                if (mDriverFD >= 0) {
                    // 调用 mmap() 函数在驱动中分配了一块内存空间, 这块空间的尺寸略小于1MB
                    // the binder, providing a chunk of virtual address space to receive transactions.
                    mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
                    if (mVMStart == MAP_FAILED) {
                        close(mDriverFD);
                        mDriverFD = -1;
                        mDriverName.clear();
                    }
                }
            }
            void ProcessState::startThreadPool() {
                AutoMutex _l(mLock);
                if (!mThreadPoolStarted) {
                    mThreadPoolStarted = true;
                    spawnPooledThread(true);
                }
            }
            void ProcessState::spawnPooledThread(bool isMain) {
                if (mThreadPoolStarted) {
                    String8 name = makeBinderThreadName();
                    sp<Thread> t = new PoolThread(isMain);
                    t->run(name.string());
                }
            }
            String8 ProcessState::makeBinderThreadName() {
                int32_t s = android_atomic_add(1, &mThreadPoolSeq);
                pid_t pid = getpid();
                String8 name;
                name.appendFormat("Binder:%d_%X", pid, s);
                return name;
            }

            /frameworks/native/libs/binder/IPCThreadState.cpp
            case BR_SPAWN_LOOPER:
                mProcess->spawnPooledThread(false);
                break;


4.4.2 Binder对象的传递
4.4.3 分析 IPCThreadState 类



4.5 Binder 驱动
4.5.1 应用层和驱动的消息协议
4.5.2 Binder 驱动分析
4.5.3 Binder 的内存共享机制
4.5.4 驱动的 ioctl 操作
4.5.5 Binder 调用过程
4.5.6 处理传递的 Binder 对象




4.6 解析名称的模块 —— ServiceManager的作用
4.6.1 ServiceManager 的架构
4.6.2 ServiceManger 提供的服务




4.7 匿名共享内存 ashmem
4.7.1 ashmem 的作用和用法
4.7.2 ashmem 驱动的实现原理
4.7.3 ashemem 驱动的代码分析
4.7.4 进程间传递文件描述符 
