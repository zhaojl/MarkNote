1.1 抽象过程
面向对象思想的实质是: 程序可以通过添加新类型的对象使自身适用于某个特定问题.
1) 万物皆为对象. 理论上可以抽取待求解问题的任何概念化构件(狗,建筑物,服务等),将其表示为程序中的对象.
2) 程序是对象的集合,它们通过发送消息来告知彼此要做的.可以把消息想象为对某个特定对象的方法的调用请求.
3) 每个对象都有自己的由其他对象所构成的存储. 换句话说,可以通过创建包含现有对象的包的方式来创建新类型的对象.
4) 每个对象都拥有类型. 按照通用的说法, "每个对象都是某个类(class)的一个实例(instance)", 这里的"类"就是"类型"的同义词. 每个类最重要的区别于其他类的特性就是"可以发送什么样的消息给它".
5) 某一特定类型的所有对象都可以接收同样的消息. 因为"圆形"类型的对象同时也是"几何形"类型的对象, 所以一个"圆形"对象必定能够接受发送给"几何形"的消息. 这意味着可以编写与"几何形"交互并自动处理所有与几何形性质相关的事物的代码. 这种可替代性(substitutability)是OOP最强有力的概念之一.

对象具有状态,行为和标识. 即每一个对象都可以拥有内部数据(状态)和方法(行为), 并且每一个对象都可以唯一的与其它对象区分开来, 具体来说, 就是每一个对象在内存中都有一个唯一的地址.

1.2 每个对象都有一个接口
类型(type):鸟类和鱼类等. 在程序中使用基本关键字 class 来引入新的类型.
创建抽象数据类型(类)是面向对象程序设计的基本概念之一. 编程系统欣然接受新的类,并且像对待内置类型一样的照管它们和进行类型检查.
面向对象程序设计的挑战之一就是在问题空间的元素和解空间的对象之间创建一对一的映射.
每个对象都只能满足某些请求, 这些请求由对象的接口(interface)所定义, 决定借口的便是类型. 接口确定了对某一特定对象所能发出的请求. 但是在程序中必须有满足这些请求的代码. 这些代码与隐藏的数据一起构成了实现. 此过程通常被概括为:向某个对象"发送消息"(产生请求), 这个对象便知道此消息的目的, 然后执行对应的程序代码.

2.2.1
1) 寄存器. 这是最快的存储区, 因为它位于不同于其他存储区的地方--处理器内部. 但是寄存器的数量是及其有限, 所以寄存器根据需求进行分配. 你不能直接控制, 也不能在程序中感觉到寄存器存在的任何迹象(C和C++允许您向编译器建议寄存器的分配方式)
2) 堆栈. 位于通用RAM中, 随机访问存储器中, 但通过堆栈指针可以从处理器那里获得直接支持. 堆栈指针若向下移动则分配新的内存; 若向上移动, 则释放那些内存. 这是一种快速有效的分配存储方法, 仅次于寄存器. 创建程序时, Java系统必须知道存储在堆栈内所有项的确切生命周期, 以便上下移动堆栈指针. 这一约束限制了程序的灵活性, 所以虽然某些Java数据存储于堆栈中--特别是对象引用, 但是Java对象并不存储于其中.
3) 堆. 一种通用的内存池, 也位于RAM区, 用于存放所有的Java对象. 堆不同于堆栈的好处是:编译器不需要知道存储的数据在堆里存活多长时间. 因此在堆里分配存储有很大的灵活性. 当需要一个对象时, 只需用new写一行简单的代码, 当执行这行代码时, 会自动在堆里进行存储分配. 当然为这种灵活性必须要付出相应的代价: 用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间.
4) 常量存储. 常量值通常直接存放在程序代码内部, 这样做是安全的, 因为它们永远不会被改变. 有时在嵌入式系统中, 常量本身会和其他部分隔离开, 所以在这种情况下, 可以选择将其存放在ROM中, 只读存储器中.
5) 非RAM存储. 如果数据完全存活于程序之外, 那么它可以不受程序的任何控制, 在程序没有运行时也可以存在. 其中两个基本的例子是流对象和持久化对象. 在流对象中, 对象转化成字节流, 通常被发送给另一台机器; 在"持久化对象"中, 对象被存放于磁盘上.